<!DOCTYPE html>
<html>
<head>
  <title>funktion.fm</title>
  <meta charset="utf-8">
  <link href='http://fonts.googleapis.com/css?family=Paytone+One' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Julius+Sans+One' rel='stylesheet' type='text/css'>
  <style>
    @font-face {
      font-family: 'Source Code Pro';
      font-style: normal;
      font-weight: 400;
      src: local('Source Code Pro'), local('SourceCodePro'), url('{{static.root}}css/sourcecodepro/sourcecodepro-light-webfont.woff') format('woff');
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Source Code Pro', sans-serif;
      font-size: 14px;
    }

    #newsBody {
      display: none;
      position: absolute;
      top: 400px;
      font-size: 14px;
      left: 400px;
      z-index: -1;
    }

    #contact {
      font-weight: bold;
      font-size: 280%; 
    }

    .menuItem {
      cursor: pointer;
      font-size: 240%;
    }

    path {
      stroke: white;
      stroke-width: 1;
      fill-opacity: 0.9;
    }

    .PiYG .core{fill: transparent} /* #000020 */
    .PiYG .black{fill: black} /* #000020 */
    .PiYG .q0{fill: #F7C24C}
    .PiYG .q1{fill: #F7C85E}
    .PiYG .q2{fill: #F5B935}
    .PiYG .q3{fill: #F5B335}
    .PiYG .q4{fill: #F7C25E}

    /*http://colorschemedesigner.com/#0I51zc.6m5219*/
    /*.PiYG .cluster{fill: #000010}
    .PiYG .q0{fill: #332A1F}
    .PiYG .q1{fill: #31291E}
    .PiYG .q2{fill: #332B1F}
    .PiYG .q3{fill: #312A1E}
    .PiYG .q4{fill: #31281E}*/

    /*text {fill: white;stroke: #444;}*/

  </style>
  <script src="js/jquery-2.0.3.min.js"></script>
  <script src="js/d3.v3.min.js"></script>
  <script src="js/underscore-min.js"></script>
</head>

<body>
  <svg>
  </svg>
  <script>
    var width = $(window).width(), height = $(window).height(), lineHeight = 20
      , i, vertices = [], clusters = []
      , tessCount = 50
      , winSize = 10
      , debugTesselations = false
      , r = height/30
      , contact, news, projects

    // d3 variables
    var svg = d3.select('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('class', 'PiYG')
      , path = svg.append('g').selectAll('path')

    var Cluster = function(opts) {
      _.extend(this, opts)
      this.core.pathClass = 'core'
      this.vertices = []
      this.state = 'collapsed'
      this.gravity = 10
      this.perturbation = 0.01
      vertices.unshift(this.core)
      clusters.push(this)

      // Generate a random-ish points :
      // 1) take points evenly distributed on a disc
      // 2) randomize a bit
      var x, y, vertex, teta
      for (i = 1; i < tessCount; i++) {
        teta = i * 2 * Math.PI / tessCount
        x = this.core[0] + r * Math.cos(teta)
        y = this.core[1] + r * Math.sin(teta)
        vertex = []
        vertex.gravityCenter = [x, y]
        
        // Randomized x and y
        x = (Math.random() * 2 - 1) * width/(1 * tessCount) + x
        y = (Math.random() * 2 - 1) * height/(1 * tessCount) + y
        vertex[0] = x
        vertex[1] = y
        
        // Extra, for animation and display
        vertex.vx = []
        vertex.vy = []
        vertex.cluster = this

        vertices.push(vertex)
        this.vertices.push(vertex)
      }

      // Create SVG text element
      this.text = svg.selectAll('text').data(clusters)
        .enter()
        .append('text')
          .text(function(d, i) { return d.text })
          .attr('class', 'menuItem')
          .attr('id', function(d, i) { return d.id })
          .on('click', function() {
            var cluster = d3.select(this).data()[0]
            cluster.expand()
          })

      this._updateText()

    }

    _.extend(Cluster.prototype, {

      expand: function() {
        var self = this
        if (this.state !== 'expanded') {
          this._expand()
          this.state = 'expanded'
          _.forEach(clusters, function(cluster) {
            if (cluster !== self) cluster.state = 'collapsed'
          })
        }
      },

      movePoints: function() {
        var self = this
          , x, y, xDist, yDist
        this.vertices.forEach(function(v, i) {
          xDist = v.gravityCenter[0] - v[0]
          yDist = v.gravityCenter[1] - v[1]
          v.vx.push(Math.random() * xDist / self.gravity + (Math.random() * 2 - 1) * self.perturbation)
          v.vy.push(Math.random() * yDist / self.gravity + (Math.random() * 2 - 1) * self.perturbation)

          // to smooth out, we compute the average from last positions
          if (v.vy.length > winSize) v.vy.shift()
          if (v.vx.length > winSize) v.vx.shift()
          v[0] = v[0] + avg(v.vx)
          v[1] = v[1] + avg(v.vy)
        })
        this._updateText()
      },

      _updateText: function() {
        var self = this
        this.text
          .attr('x', function(d) { return d.core[0] - this.textContent.length * 10 })
          .attr('y', function(d) { return d.core[1] + 7 })
      }

    })

    contact = new Cluster({id: 'contact', text: 'funktion.fm', core: [width/8, height/7]})
    news = new Cluster({id: 'news', text: 'NEWS', core: [0.5 * width, 2 * height/5]})
    projects = new Cluster({id: 'projects', text: 'PROJECTS', core: [7 * width/8, height/7]})

    news._expand = function() {
      var self = this, teta
      _.forEach(this.vertices, function(vertex, i) {
        teta = i * 2 * Math.PI / tessCount
        vertex.gravityCenter = [self.core[0] + 10000 * Math.cos(teta), self.core[1] + 10000 * Math.sin(teta)]
      })
    }

    projects._expand = function() {
      var self = this, teta
      _.forEach(this.vertices, function(vertex, i) {
        teta = i * 2 * Math.PI / tessCount
        vertex.gravityCenter = [self.core[0] + 10000 * Math.cos(teta), self.core[1] + 10000 * Math.sin(teta)]
      })
    }

    contact._expand = function() {
      var self = this
        , teta, radiuses = []
        , x, y

      var makeFlower = function(cluster) {
        var radiusAvg = avg(radiuses)
        _.forEach(cluster.vertices, function(vertex, i) {
          if (distance(vertex.gravityCenter, cluster.core) > radiusAvg)
            vertex.pathClass = 'black'
        })
        radiuses = []      
      }

      self.core = [width/10, height/15]

      _.forEach(this.vertices, function(vertex, i) {
        teta = i * 2 * Math.PI / tessCount
        vertex.gravityCenter = [
          self.core[0] + 600 * Math.cos(teta) * (0.8 + Math.random() * 0.2),
          self.core[1] + 600 * Math.sin(teta) * (0.8 + Math.random() * 0.2)
        ]
        radiuses.push(distance(vertex.gravityCenter, self.core))
      })
      makeFlower(this)
      
      news.core[0] = 0.8 * width
      news.core[1] = 4 * height/5
      //projects.core = [7 * width/8, height/7]
      _.forEach([news, projects], function(cluster) {
        _.forEach(cluster.vertices, function(vertex, i) {
          teta = i * 2 * Math.PI / tessCount
          vertex.gravityCenter = [
            cluster.core[0] + 200 * Math.cos(teta) * (0.8 + Math.random() * 0.2),
            cluster.core[1] + 200 * Math.sin(teta) * (0.8 + Math.random() * 0.2)
          ]
          radiuses.push(distance(vertex.gravityCenter, cluster.core))
        })
        makeFlower(cluster)
      })
    }


    // Calculate Voronoi tesselation
    var calculateTesselation = function() {
      return d3.geom.voronoi(vertices).map(function(d, i) {
        return { d: 'M' + d.join('L') + 'Z' }
      })
    }

    // Draw tesselation
    var drawTesselations = function() {
      if (debugTesselations) {
        svg.selectAll('circle').data(vertices).enter().append('circle')
          .attr('r', function (d) { return 5 })
          .attr('fill', 'grey')
        svg.selectAll('circle').data(vertices)
          .attr('cx', function (d) { return d[0] })
          .attr('cy', function (d) { return d[1] })
      }

      path = path.data(calculateTesselation())
      path.exit().remove()
      path.enter()
        .append('path')
      path
        .attr('class', function(d, i) {
          return vertices[i].pathClass || ('q' + (i % 4) + ' q')
        })
        .attr('d', function(d) { return String(d.d) })
      path.order()
    }

    // Helpers
    var distance = function(a, b) {
      return Math.pow(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2), 0.5)
    }

    var avg = function(array) {
      return _.reduce(array, function(tot, val) { return tot + val }, 0) / array.length
    }

    var sign = function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0 }

    // Animate the thing
    drawTesselations()
    setInterval(function() {
      clusters.forEach(function(cluster) { cluster.movePoints() })
      drawTesselations()
    }, 20)
  </script>

  <div id="newsBody">
  {{#each getPosts}}
    <div class="postTitle">{{title}}</div>
    <div class="postTags">{{tags}}</div>
    <div class="postDate">{{date}}</div>
    <div class="postContent">{{{content}}}</div>
  {{/each}}
  </div>

</body>

</html>
